/**
 * @description       : 
 * @author            : rajendra_singh.nagar@syngenta.com
 * @last modified on  : 06-25-2021
 * @last modified by  : rajendra_singh.nagar@syngenta.com
 * Modifications Log 
 * Ver   Date         Author                              Modification
 * 1.0   05-29-2021   rajendra_singh.nagar@syngenta.com   Initial Version
**/
public inherited sharing class Google_Sum2Value {

    /**
     * * Approach # 1: Using 2 arrays
     * ! Complexity: O(n^2)
     * 1. Clone the input stream.
     * 2. Use 2 for loops & check the sum of each value in array with all values of new array.
     *  2.1 If any sum is equal to the number passed, return both values.
     *  2.2 If there is no match return -1.
     */
    public List<Integer> checkSumOfValue(List<Integer> stream, Integer x){
        // Clone the Array
        List<Integer> clonnedStream = stream.clone();
        for(Integer outStrm: stream){
            for(Integer inStrm: clonnedStream){
                if(outStrm+inStrm==x){
                    return new List<Integer>{outStrm, inStrm};
                }
            }
        }
        
        // After all iterations, return false. This means no two values sum is equal to the passed number.
        return new List<Integer>{-1, -1};
    }

    /**
     * * Approach 2: Using Sets -> This is similar to Hashing technique where we use HashSet
     * ! Complexity: O(n)
     * 1. Iterate over the passed stream.
     * 2. For each iteration, substract the value from the passed number. 
     * 3. Pass the substracted value in the set and check the set for each iteration.
     * 3. If the stream contains the substracted value
     */
    public List<Integer> checkSumOfValueSet(List<Integer> stream, Integer x){
        Set<Integer> valueSet = new Set<Integer>();
        for(Integer strmVal: stream){
            if(valueSet.contains(x-strmVal)){
                return new List<Integer>{strmVal, x-strmVal};
            }
            valueSet.add(strmVal);
        }
        return new List<Integer>{-1,-1};
    }

    /**
     * * Approach # 3: Find using indexOf (Stream should be sorted)
     * * Sorting and Binary Search
     * ! Time Complexity: Time complexity of sorting + n. Time complexity of Binary Search = O(nlogn) + n.O(logn) = O(nlogn)
     * 1. Iterate over the passed stream. 
     * 2. For each iteration, subtract the value from the passed number.
     * 3. Check if the substracted value is present in the stream.
     * 4. If yes, passed both values, else return -1.
     */
    public List<Integer> checkSumOfValueFind(List<Integer> stream, Integer x){
        stream.sort(); // In java we do binary search
        // Iterate over the stream
        for(Integer i=0; i< stream.size() ; i++){
            Integer siblingIndex = stream.indexOf(x-stream[i]);
            if(siblingIndex!=-1){
                // Check if it is not the same index. If it is same, than check both side to have the same value.
                if(siblingIndex!=i || (i>0 && stream[i-1]==stream[i] || (i<stream.size()-1 && stream[i+1]==stream[i]))){
                    // return both the numbers 
                    return new List<Integer>{stream[i], x-stream[i]};
                }
            }
        }
        
        // If no match is found, return -1
        return new List<Integer>{-1,-1};
    }

    /**
     * * Approach # 4: Sort & walk inward - Two Pointer approach
     * ! Time Complexity: O(nlogn)
     * 1. Iterate over the passed sorted stream. 
     * 2. Initialize two variables pointing at zeroth index & at length of array.
     * 3. Now, iterate using loop while lhs < rhs.
     * 4. if (value[lhs]==value[rhs]), return both values.
     * 5. if sum of lhs & rhs value is < x, this means that value is present on more right side. Increment lhs & go for next iteration.
     * 6. if sum of lhs & rhs value is > x, this means that value is present on more left side. decrement rhs & go for next iteration.
     * 7. if not found, return -1 in the last.
     */
    public List<Integer> checkSumOfValue2Pointer(List<Integer> stream, Integer x){
        // Sort the stream
        stream.sort();

        // get left & right side indexes
        Integer lhs=0, rhs=stream.size()-1;
        while (lhs<rhs){
            Integer sum = stream[lhs]+stream[rhs];
            if(sum==x){
                return new List<Integer>{stream[lhs], stream[rhs]};
            }
            if(sum<x){
                // that means we have to move from left to right
                lhs++;
            }else{
                rhs--;
            }
        }
        // else return -1
        return new List<Integer>{-1,-1};
    }
}